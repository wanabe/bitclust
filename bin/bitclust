#!/usr/bin/env ruby
#
# bitclust.rb
#
# Copyright (c) 2006-2008 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the Ruby License.
#

require 'pathname'

def srcdir_root
  Pathname.new(__FILE__).realpath.dirname.parent.cleanpath
end

$LOAD_PATH.unshift srcdir_root() + 'lib'

unless Object.const_defined?(:Encoding)
  $KCODE = 'EUC'
end

require 'bitclust'
require 'bitclust/subcommand'

def main
  Signal.trap(:PIPE, 'IGNORE') rescue nil   # Win32 does not have SIGPIPE
  Signal.trap(:INT) { exit 3 }
  _main
rescue Errno::EPIPE
  exit 0
end

def _main
  prefix = nil
  version = nil
  capi = false
  parser = OptionParser.new
  parser.banner = <<-EndBanner
Usage: #{File.basename($0, '.*')} [global options] <subcommand> [options] [args]

Subcommands:
    init        Initialize database.
    list        List libraries/classes/methods in database.
    lookup      Lookup a library/class/method from database.
    search      Search classes/methods from database.
    query       Dispatch arbitrary query.
    update      Update database.
    property    Handle database properties.
    setup       Initialize and update database with default options.

Global Options:
  EndBanner
  parser.on('-d', '--database=PATH', 'Database prefix.') {|path|
    prefix = path
  }
  parser.on('-t', '--targer=VERSION', 'Specify Ruby version.') {|v|
    version = v
  }
  parser.on('--capi', 'Process C API database.') {
    capi = true
  }
  parser.on('--version', 'Print version and quit.') {
    puts BitClust::VERSION
    exit 0
  }
  parser.on('--help', 'Prints this message and quit.') {
    puts parser.help
    exit 0
  }

  subcommands = {}
  subcommands['init']     = BitClust::InitCommand.new
  subcommands['list']     = BitClust::ListCommand.new
  subcommands['lookup']   = BitClust::LookupCommand.new
  subcommands['search']   = BitClust::Searcher.new
  subcommands['query']    = BitClust::QueryCommand.new
  subcommands['update']   = BitClust::UpdateCommand.new
  subcommands['property'] = BitClust::PropertyCommand.new
  subcommands['setup']    = BitClust::SetupCommand.new
  subcommands['server']   = BitClust::ServerCommand.new
  begin
    parser.order!
    if ARGV.empty?
      $stderr.puts 'no sub-command given'
      $stderr.puts parser.help
      exit 1
    end
    name = ARGV.shift
    cmd = subcommands[name] or error "no such sub-command: #{name}"
  rescue OptionParser::ParseError => err
    $stderr.puts err.message
    $stderr.puts parser.help
    exit 1
  end
  begin
    cmd.parse(ARGV)
  rescue OptionParser::ParseError => err
    $stderr.puts err.message
    $stderr.puts cmd.help
    exit 1
  end
  case name
  when "sestup", "server"
    db = nil
  else
    home_directory = Pathname(ENV['HOME'])
    config_path = home_directory + ".bitclust/config"
    if config_path.exist?
      config = YAML.load_file(config_path)
      version ||= config[:default_version]
      prefix ||= "#{config[:database_prefix]}-#{version}"
    end
    unless prefix
      $stderr.puts "no database given. Use --database option"
      exit 1
    end
    if capi
      db = BitClust::FunctionDatabase.new(prefix)
    else
      db = BitClust::MethodDatabase.new(prefix)
    end
  end
  cmd.exec db, ARGV
rescue BitClust::WriterError => err
  raise if $DEBUG
  error err.message
end

def error(msg)
  $stderr.puts "#{File.basename($0, '.*')}: error: #{msg}"
  exit 1
end

main
